import datetime
import re
import numpy as np
from snapshot.ca_core import Snapshot, SnapshotReqFile
from snapshot.parser import parse_to_save_file, parse_from_save_file
from epics import PV

class snapshot:
    def __init__(self,filename=None,savepath='/sf/data/applications/snapshot/'):
        self.filename = filename
        self.savepath = savepath
        self.tolerance=0.0005  
        self.pvnames=[]
        self.pvs=[]
        self.mppvnames=[]
        self.mppvs=[]
        self.machinepar=[]
        self.message=''
        if self.filename:
            self.openRequestFile(self.filename)


    def openRequestFile(self,filename):
        self.filename = filename
        self.rootname=self.filename.split('/')[-1]
        req_file = SnapshotReqFile(self.filename)
        pvs_list = req_file.read()
        self.pvnames.clear()
        self.machinepar.clear()
        for ele in pvs_list:
            if isinstance(ele,list):
                self.pvnames=ele
            elif isinstance(ele,dict):
                if 'machine_params' in ele.keys():
                    self.machinepar=ele['machine_params']        
        self.connectPVs()
        
    def connectPVs(self):
        self.pvs=[PV(pv) for pv in self.pvnames]
        con = [pv.wait_for_connection(timeout=0.5) for pv in self.pvs]
        for i,val in enumerate(con):
            if val is False:
                print('Cannot connect to PV:', self.pvs[i].pvname)
        self.mppvnames=[mp[0] for mp in self.machinepar]
        self.mppvs=[PV(mp[1]) for mp in self.machinepar]
        con = [pv.wait_for_connection(timeout=0.5) for pv in self.mppvs]
        for i,val in enumerate(con):
            if val is False:
                print('Cannot connect to PV:', self.mppvs[i].pvname)
        
    def getSnapValues(self, force = True):
        values={}
        for pv in self.pvs:
            val = pv.get_with_metadata(timeout=0.1)        
            if force is False and val["value"] is None:
                return False
            values[pv.pvname]={"raw_name":pv.pvname,"val":val["value"]}
            if 'units' in val.keys():
                values[pv.pvname]['egu']=val['units']
            else:
                values[pv.pvname]['egu']=None
            if 'precision' in val.keys():
                values[pv.pvname]['prec']=val['precision']
            else:
                values[pv.pvname]['prec']=None        
        mvalues={}
        for i in range(len(self.mppvnames)):
            val = self.mppvs[i].get_with_metadata(timeout=0.1)        
            if force is False and val["value"] is None:
                return False            
            tag={"value":val["value"]}
            if 'units' in val.keys():
                tag['units']=val['units']
            if 'precision' in val.keys():
                tag['precision']=val['precision']
            mvalues[self.mppvnames[i]]=tag
        return values,mvalues
 
            
    def save(self,labels=[],comment="Generated by SFBD-Package",force=True):
        if self.filename is None:
            self.message = 'No Request File Loaded'
            return False

        val,mval = self.getSnapValues(force)
        if isinstance(val,bool) and val == False:
            self.message = 'Unsuccesful reading of PV channels (unforced access)'
            return False
        
        # construct file name
        datetag = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        root = self.rootname.split('.req')[0]
        files = self.savepath+root+'_'+datetag+'.snap'
        filel = self.savepath+root+'_latest.snap'
        # save file
        parse_to_save_file(val, files, macros=None, symlink_path=filel,
                           comment=comment,labels=[],req_file_name=self.rootname,machine_params=mval)
        self.message = 'Snapshot saved to '+files
        return True


    def restore(self,filename,refilter='',force=True):
        filepath=self.savepath+filename
        prog=re.compile(refilter)
        save_pvs=parse_from_save_file(filepath)
        res={}
        for ele in save_pvs:
            if isinstance(ele,dict):
                for key in ele.keys():
                    if prog.match(key):
                        res[key]=ele[key]['value']
                        
        for pv in self.pvs:
            if pv.pvname in res.keys():
                val=pv.get()
                if val is None or np.abs(val-res[pv.pvname]) > self.tolerance:
                    pv.put(res[pv.pvname])
        self.message ='Snap restored'
